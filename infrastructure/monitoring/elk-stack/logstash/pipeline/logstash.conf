input {
  # Docker logs
  beats {
    port => 5044
  }
  
  # TCP input for structured logs
  tcp {
    port => 5000
    codec => json_lines
  }
  
  # UDP input for syslog
  udp {
    port => 5000
    codec => json_lines
  }
  
  # HTTP input for application logs
  http {
    port => 8080
    codec => json
  }
}

filter {
  # Parse Docker container logs
  if [container][name] {
    mutate {
      add_field => { "service_name" => "%{[container][name]}" }
    }
  }
  
  # Parse application logs with correlation IDs
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      target => "app_log"
    }
    
    if [app_log][correlation_id] {
      mutate {
        add_field => { "correlation_id" => "%{[app_log][correlation_id]}" }
      }
    }
    
    if [app_log][service] {
      mutate {
        add_field => { "service_name" => "%{[app_log][service]}" }
      }
    }
    
    if [app_log][level] {
      mutate {
        add_field => { "log_level" => "%{[app_log][level]}" }
      }
    }
    
    if [app_log][timestamp] {
      date {
        match => [ "[app_log][timestamp]", "ISO8601" ]
        target => "@timestamp"
      }
    }
  }
  
  # Parse Nginx access logs
  if [service_name] == "nginx" and [message] =~ /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/ {
    grok {
      match => { 
        "message" => "%{IPORHOST:client_ip} - %{DATA:user} \[%{HTTPDATE:timestamp}\] \"%{WORD:method} %{URIPATH:path}(?:%{URIPARAM:params})? HTTP/%{NUMBER:http_version}\" %{NUMBER:status_code} %{NUMBER:response_size} \"%{DATA:referer}\" \"%{DATA:user_agent}\" %{NUMBER:response_time}"
      }
    }
    
    date {
      match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
    }
    
    mutate {
      add_field => { "log_type" => "access" }
    }
  }
  
  # Parse application error logs
  if [log_level] == "error" or [log_level] == "fatal" {
    mutate {
      add_field => { "alert_level" => "high" }
    }
  }
  
  # Parse database connection logs
  if [message] =~ /database|postgres|mysql|redis/ {
    mutate {
      add_field => { "log_category" => "database" }
    }
  }
  
  # Parse authentication logs
  if [message] =~ /auth|login|jwt|token/ {
    mutate {
      add_field => { "log_category" => "security" }
    }
  }
  
  # Parse performance logs
  if [message] =~ /slow|timeout|latency|performance/ {
    mutate {
      add_field => { "log_category" => "performance" }
    }
  }
  
  # Add environment and cluster information
  mutate {
    add_field => { "environment" => "production" }
    add_field => { "cluster" => "writewave" }
  }
  
  # Remove sensitive information
  mutate {
    remove_field => [ "password", "token", "secret", "key" ]
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "writewave-logs-%{+YYYY.MM.dd}"
    template_name => "writewave-logs"
    template => "/usr/share/logstash/templates/writewave-logs.json"
    template_overwrite => true
  }
  
  # Send critical errors to alerting system
  if [alert_level] == "high" {
    http {
      url => "http://alertmanager:9093/api/v1/alerts"
      http_method => "post"
      format => "json"
      mapping => {
        "alerts" => [
          {
            "labels" => {
              "alertname" => "CriticalError"
              "service" => "%{service_name}"
              "severity" => "critical"
            }
            "annotations" => {
              "summary" => "Critical error in %{service_name}"
              "description" => "%{message}"
            }
            "startsAt" => "%{@timestamp}"
          }
        ]
      }
    }
  }
  
  # Debug output (remove in production)
  stdout {
    codec => rubydebug
  }
}
